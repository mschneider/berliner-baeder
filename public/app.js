// Generated by IcedCoffeeScript 1.2.0i
var App, iced, __iced_k,
  __slice = [].slice;

iced = {
  Deferrals: (function() {

    function _Class(_arg) {
      this.continuation = _arg;
      this.count = 1;
      this.ret = null;
    }

    _Class.prototype._fulfill = function() {
      if (!--this.count) return this.continuation(this.ret);
    };

    _Class.prototype.defer = function(defer_params) {
      var _this = this;
      ++this.count;
      return function() {
        var inner_params, _ref;
        inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (defer_params != null) {
          if ((_ref = defer_params.assign_fn) != null) {
            _ref.apply(null, inner_params);
          }
        }
        return _this._fulfill();
      };
    };

    return _Class;

  })(),
  findDeferral: function() {
    return null;
  }
};
__iced_k = function() {};

App = (function() {

  App.name = 'App';

  function App() {}

  App.prototype.distance = function(position, bath) {
    var lat1, lat2, lng1, lng2, x, y;
    lat1 = position.coords.latitude;
    lng1 = position.coords.longitude;
    lat2 = Number(bath.location.lat);
    lng2 = Number(bath.location.lng);
    x = (lng2 - lng1) * Math.cos((lat1 + lat2) / 2);
    y = lat2 - lat1;
    return Math.sqrt(x * x + y * y);
  };

  App.prototype.findBath = function(position) {
    var bath, closestBath, _i, _len;
    for (_i = 0, _len = Baths.length; _i < _len; _i++) {
      bath = Baths[_i];
      closestBath || (closestBath = bath);
      bath.distance = this.distance(position, bath);
      if (closestBath.distance > bath.distance) closestBath = bath;
    }
    return closestBath;
  };

  App.prototype.reverseGeocode = function(lat, lng, cb) {
    var data, error, latlng, sensor, success;
    latlng = lat + ',' + lng;
    sensor = false;
    data = {
      latlng: latlng,
      sensor: sensor
    };
    success = cb;
    error = function(jqXHR, textStatus, errorThrown) {
      console.error('error when reverse geocoding', latlng);
      console.error('resonse status was', textStatus);
      return cb();
    };
    return $.ajax('http://maps.googleapis.com/maps/api/geocode/json', {
      data: data,
      success: success,
      error: error
    });
  };

  App.handleGeolocation = function(position) {
    var address, app, bath, lat, lng, ___iced_passed_deferral, __iced_deferrals,
      _this = this;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    app = new App;
    lat = position.coords.latitude;
    lng = position.coords.longitude;
    console.log("you are at:", lat, lng);
    bath = app.findBath(position);
    console.log("closest bath:", bath.name);
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: 'app/app.coffee',
        funcname: 'App.handleGeolocation'
      });
      app.reverseGeocode(lat, lng, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return address = arguments[0];
          };
        })(),
        lineno: 37
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return console.log("closest address:", address);
    });
  };

  return App;

})();
